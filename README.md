# Getopt 및 getopts 명령
## 1. Getopt 명령
#### 용도: 
명령행 플래그와 매개변수를 구문 분석합니다.


#### 설명:
getopt 명령은 예상되는 플래그와 인수를 지정하는 형식을 사용하여 토큰 리스트를 구문 분석합니다. 플래그는 단일 ASCII 문자이며 뒤에 :(콜론)이 올 경우 하나 이상의 탭 또는 공백으로 분리하거나 분리할 수 없는 인수가 있어야 합니다. 인수에는 복수 바이트를 포함시킬 수 있지만 플래그 문자로는 포함시킬 수 없습니다.

getopt 명령은 모든 토큰을 읽은 후 또는 특수 토큰 -(더블 하이픈)이 발생하는 경우 처리를 완료합니다. 그러면 getopt 명령은 처리된 플래그, -(더블 하이픈) 및 남아 있는 토큰을 출력합니다.

토큰이 플래그와 일치하는 데 실패하는 경우 getopt 명령은 메시지를 표준 오류에 기록합니다.

#### 예제:
다음 예제에서와 같이 getopt 명령을 스켈레톤 쉘 스크립트에서 사용하여 옵션을 구문 분석할 수 있습니다.

```
#!/usr/bin/bsh
#parse command line into arguments
set -- `getopt a:bc $*`
#check result of parsing
if [ $? != 0 ]
then
        exit 1
fi
while [ $1 != -- ]
do
        case $1 in
        -a)     # set up the -a flag
                AFLG=1
                AARG=$2
                shift;;
        -b)     # set up the -b flag
                BFLG=1;;
        -c)     # set up the -c flag
                CFLG=1;;
        esac
        shift   # next flag
done
shift   # skip --
# now do the work
.
.
.
```


## 2. Getopts 명령
#### 용도:
명령행 인수를 처리하고 유효한 옵션을 검사합니다.


#### 설명:
getopts 명령은 매개변수 리스트에서 옵션 및 옵션 인수를 검색하는 Korn/POSIX 쉘 내장 명령입니다. 옵션은 +(더하기 부호) 또는 -(빼기 부호)로 시작하고 그 뒤에 문자가 옵니다. + 또는 -로 시작하지 않는 옵션은 OptionString을 종료합니다. getopts 명령은 호출될 때마다 Name의 다음 옵션 값과 쉘 변수 OPTIND에서 처리될 다음 인수의 색인을 배치합니다. 쉘이 호출될 때마다 OPTIND는 1로 초기화됩니다. 옵션이 +로 시작되는 경우 +는 Name의 값 앞에 추가됩니다.

OptionString의 문자 뒤에는 :(콜론)이 오면 옵션에 인수가 있는 것으로 간주됩니다. 옵션에 옵션-인수가 필요한 경우 getopts 명령은 이를 변수 OPTARG에 배치합니다.

OptionString에 포함되지 않은 옵션 문자가 발견되거나 찾은 옵션에 필요한 옵션-인수가 없는 경우:

OptionString이 :(콜론)으로 시작되지 않는 경우
Name은 ?(물음표) 문자로 설정됩니다.
OPTARG가 설정되지 않으며
진단 메시지가 표준 오류에 기록됩니다.
이 조건은 getopts 명령을 처리하는 중에 생긴 오류가 아니라 호출 애플리케이션에 인수가 표시되는 중에 발견된 오류라고 간주됩니다. 진단 메시지는 명시된 대로 기록되지만 종료 상태는 0이 됩니다.

OptionString이 :(콜론)으로 시작되는 경우
Name은 ?(물음표)로 설정되거나 누락된 필수 옵션에 대해서는 :(콜론) 문자로 설정됩니다.
OPTARG는 발견된 옵션 문자로 설정되고
출력이 표준 오류에 기록되지 않습니다.
다음 중 하나가 옵션의 끝을 식별합니다. 특수 옵션 - -,이 - 또는 +로 시작되지 않는 인수를 찾는 경우 또는 오류가 발생하는 경우.

옵션의 끝에 도달하는 경우:

getopts 명령은 0보다 큰 리턴 값으로 종료됩니다.
OPTARG는 첫 번째 비옵션-인수의 색인으로 설정됩니다. 여기서, 첫 번째 - - 인수는 그 전에 다른 비옵션-인수가 나타나지 않는 경우 옵션-인수로 간주되고 비옵션-인수가 없는 경우에는 값 $#+1로 간주됩니다.
Name은 ?(물음표) 문자로 설정됩니다.

#### 예제:


다음 getopts 명령은 a, b 및 c가 유효한 옵션이고 a 및 c 옵션에 인수가 있음을 지정합니다.
```
getopts a:bc: OPT
```

다음 getopts 명령은 a, b 및 c가 유효한 옵션이고 a 및 b 옵션에는 인수가 있으며 명령행에서 정의되지 않은 옵션을 발견하는 경우 getopts가 OPT의 값을 ?로 설정하도록 지정합니다.
```
getopts :a:b:c OPT
```

다음 스크립트가 인수를 구문 분석하고 표시합니다
```

aflag=
bflag=
 
while getopts ab: name
do
            case $name in
            a)     aflag=1;;
            b)     bflag=1
                          bval="$OPTARG";;
            ?)     printf "Usage: %s: [-a] [-b value] args\n" $0
                          exit 2;;
           esac
done
 
if [ ! -z "$aflag" ]; then
           printf "Option -a specified\n"
fi
 
if [ ! -z "$bflag" ]; then
           printf 'Option -b "%s" specified\n' "$bval"
fi
 
shift $(($OPTIND -1))
printf "Remaining arguments are: %s\n" "$*"
```
# Sed 및 awk 명령
## 1. Sed 명령
#### 용도:
스트림 편집기

#### 설명:
sed 명령은 편집 스크립트에 따라 지정된 File 매개변수에서 행을 수정하고 표준 출력에 작성합니다. sed 명령에는 수정하려는 행을 선택하고 선택된 행만 변경하기 위한 많은 기능이 포함됩니다.

sed 명령은 수정되는 행을 보유하기 위해 두 개의 작업공간을 사용합니다. 즉, 선택된 행이 보유되는 곳에는 패턴 공간을 사용하고 행이 임시로 저장될 수 있는 곳에는 보유 공간을 사용합니다.

편집 스크립트는 별도의 각 행에 개별 부속 명령으로 구성됩니다. sed 부속 명령의 일반 형식은 다음과 같습니다.

[address-range] function[modifiers]

sed 명령은 입력 행을 패턴 공간으로 읽어들이고 주소가 해당 행을 선택하는 순서로 모든 sed 부속 명령을 적용하며 표준 출력에 패턴 공간을 기록하여 각 입력 File 매개변수를 처리합니다. 그런 다음, 패턴 공간을 지우고 입력 File 매개변수에 지정되는 각 행에 대해 이 프로세스를 반복합니다. 일부 sed 부속 명령은 보류 영역을 사용하여 후속 검색을 위해 패턴 공간의 일부 또는 모두를 저장합니다.

명령에 주소(행 번호 또는 검색 패턴)가 포함될 때, 주소 지정된 행 또는 행만 명령에 의해 영향을 받습니다. 그렇지 않으면, 명령이 모든 행에 적용됩니다.

입력의 마지막 행을 주소 지정하는 주소는 10진수 행 번호인 $(달러 기호) 또는 문맥 주소입니다. 문맥 주소는 다음 차이점을 제외하고 ed 명령에 사용되는 것과 유사한 정규식입니다.

패턴에 대한 문자 분리 문자를 선택할 수 있습니다. 표현식의 일반 양식은 다음과 같습니다.

\?pattern?

여기서 ? (물음표)는 선택 가능한 문자 분리 문자입니다. 공간 또는 줄 바꾸기 문자를 제외하고 현재 로케일에서 문자를 선택할 수 있습니다. \(백슬래시) 문자는 ?(물음표)의 첫 번째 발생에만 필요합니다.
패턴의 디폴트 양식은 다음과 같습니다.

/pattern/

\(백슬래시) 문자는 필요하지 않습니다.
\n 시퀀스는 줄 바꾸기 문자 종료를 제외하고 패턴 공간에서 줄 바꾸기 문자와 일치합니다.
. (마침표)는 줄 바꾸기 문자 종료를 제외하고 문자와 일치합니다. 즉, 행의 중간에 줄 바꾸기 문자와 일치할 수 없는 ed 명령과는 달리, sed 명령은 패턴 공간의 줄 바꾸기 문자와 일치할 수 있습니다.
addressed 명령이라는 특정한 명령을 사용하면 명령이 적용되어야 하는 행의 범위 또는 하나의 행을 지정할 수 있습니다. 다음 규칙은 주소 명령에 적용됩니다.

주소가 없는 명령행은 모든 행을 선택합니다.
문맥 형식으로 표시된 하나의 주소가 있는 명령행은 그 주소와 일치하는 각 행을 선택합니다.
쉼표로 구분된 두 개의 주소를 가지는 명령행은 두 번째 주소와 일치하는 다음 행을 통해 첫 번째 주소와 일치하는 첫 번째 행에서 전체 범위를 선택합니다. (두 번째 주소가 처음 선택된 회선 번호 이하인 경우, 하나의 행만 선택됩니다.) 그 후에, 첫 번째 주소를 다시 검색하여 프로세스가 반복됩니다.

#### 예제:
글로벌 변경을 수행하려면 다음을 입력하십시오.
```
sed  "s/happy/enchanted/g" chap1  >chap1.new
```

이 명령 시퀀스는 chap1 파일에서 발견되는 happy 단어의 각 발생을 enchanted 단어로 대체합니다. chap1.new라는 개별 파일에 편집한 버전을 입력합니다. s 부속 명령의 끝에 있는 g 문자는 sed 명령으로 각 행에서 여러 번 대체가 지시됩니다. g 문자 없이, sed 명령은 행에서 happy 단어의 첫 번째 발생만 대체합니다.
sed 명령은 필터로 작동합니다. 표준 입력 또는 명령행에서 이름 붙여진 파일(이 예제의 경우, chap1)에서 텍스트를 읽고 이 텍스트를 수정하여 표준 출력에 작성합니다. 대부분의 편집기와는 달리, 원래 파일을 대체하지 않습니다. 파이프라인에서 사용될 때 이는 sed 명령을 강력한 명령으로 만듭니다.

sed 명령을 파이프라인에서 필터로 사용하려면 다음과 같이 입력하십시오.
```
pr  chap2 | sed "s/Page *[0-9]*$/(&)/" | enq
```
이 명령 시퀀스는 파일 chap2를 인쇄하기 전에 페이지 번호를 괄호로 묶습니다. pr 명령은 각 페이지의 맨 위에 표제와 페이지 번호를 두고, sed 명령이 페이지 번호를 괄호에 넣고 enq 명령이 편집된 목록을 인쇄합니다.
```
sed 명령 패턴 /Page *[0-9]*$/은 행의 마지막에 나타나는 페이지 번호와 일치합니다. s 부속 명령은 이를 (&)로 변경하고, 여기서 &가 일치되는 페이지 번호를 나타냅니다.
```
파일의 선택된 행을 표시하려면 다음을 입력하십시오.
```
sed  -n  "/food/p" chap3
```
sed -n은 food 단어를 포함하는 파일 chap3에 각 행을 표시합니다. 일반적으로, sed 명령은 편집된 후 표준 출력으로 모든 행을 복사합니다. -n 플래그는 sed 명령이 이를 수행하지 못하게 합니다. p와 같은 부속 명령을 사용하여 텍스트의 특정 부분을 작성합니다. -n 플래그 없이, 이 예는 모든 행을 파일 chap3에 표시하고 food를 포함하는 각 행을 두 번씩 표시합니다.
복잡한 편집을 수행하려면 다음을 입력하십시오.
```
sed  -f  script.sed  chap4  >chap4.new
```
이 명령 시퀀스는 복잡한 것을 수행하려고 할 때 sed 스크립트 파일을 작성합니다. 사용하기 전에 스크립트를 테스트하고 수정할 수 있습니다. 스크립트를 다시 사용하여 다른 파일을 편집할 수도 있습니다. 대화식 텍스트 편집기로 스크립트 파일을 작성하십시오.
샘플 sed 스크립트 파일은 다음과 같습니다.

```
:join
/\\$/{N
s/\\\n//
b join
}
```
이 sed 스크립트는 \(백슬래시)로 끝나는 각 행을 다음에 오는 행과 결합합니다. 먼저, 패턴 /\\$/ 는 {}(중괄호)로 묶인 명령 그룹을 위해 \로 끝나는 행을 선택합니다. N 부속 명령이 줄 바꾸기 문자를 임베드하여 다음 행을 추가합니다. s/\\\n//은 \를 삭제하고 줄 바꾸기 문자를 임베드합니다. 마지막으로, b join은 새로 결합된 행의 끝에서 \ 를 검사하기 위해 레이블 b join으로 다시 분기합니다 분기 없이, sed 명령은 결합된 행을 쓰고 두 번째  \를 검사하기 전에 다음 것을 읽습니다.

## 2. Awk 명령
#### 용도:
파일에서 패턴이 일치하는 행을 찾아서 그러한 행에 지정한 조치를 수행합니다.

#### 설명:
awk 명령은 사용자가 제공하는 명령어 세트를 사용하여 사용자가 제공한 확장 정규식과 파일 세트를 한 번에 한 행씩 비교합니다. 그런 다음, 확장 정규식과 일치하는 모든 행에서 조치를 실행합니다.

awk 명령의 패턴 검색은 grep 명령의 패턴 검색보다 더 일반적이고, 이 경우 사용자는 입력 텍스트 행에 대해 여러 가지 조치를 실행할 수 있습니다. awk 명령 프로그래밍 언어에는 컴파일이 필요하지 않으며, 사용자는 변수, 숫자 함수, 문자열 함수, 논리적 연산자를 사용할 수 있습니다.

awk 명령은 LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_NUMERIC, NLSPATH, PATH 환경 변수의 영향을 받습니다.

#### 예제:

72자보다 긴 파일 행을 표시하려면 다음을 입력하십시오.
```
awk  'length  >72'  chapter1
```
이 명령은 chapter1 파일에서 72자보다 긴 각 행을 선택하여 이 행을 표준 출력으로 작성합니다. Action이 지정되지 않았기 때문입니다. 탭 문자는 1바이트로 계산됩니다.
단어 start 및 stop 사이의 모든 행을 표시하려면( "start" 및 "stop" 포함) 다음을 입력하십시오.
```
awk  '/start/,/stop/'  chapter1
```
chapter1 파일을 처리하는 awk 명령 프로그램, sum2.awk를 실행하려면 다음을 입력하십시오.
```
awk  -f  sum2.awk  chapter1
```
다음 프로그램, sum2.awk는 입력 파일, chapter1의 두 번째 열에서 숫자의 합계와 평균을 계산합니다.
```
{
       sum += $2
    }
END {
       print "Sum: ", sum;
       print "Average:", sum/NR;
    }
```
첫 번째 조치는 각 행의 두 번째 필드 값을 변수 sum에 더합니다. 모든 변수는 처음 참조될 때 0(영) 숫자 값으로 초기화됩니다. 두 번째 조치 앞에 나오는 END 패턴으로 해당 조치는 입력 파일 모두를 읽은 후에 수행됩니다. 평균을 계산하기 위하여 사용되는 NR 특별 변수는 읽은 레코드의 수를 지정하는 특별 변수입니다.
반대 순서로 처음 두 개 필드를 인쇄하려면 다음을 입력하십시오.
```
awk '{ print $2, $1 }' chapter1
```
